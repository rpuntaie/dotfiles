"
" Vim: configuration file.
"
"-----------------------"
" {NeoBundle Scripts} "
"-----------------------"

if has('vim_starting')
  if &compatible
    set nocompatible               " Be iMproved
  endif

  " Required:
  set runtimepath+=/home/fnux/.config/vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('/home/fnux/.config/vim/bundle'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

" Add or remove your Bundles here:

" Neo-completion with cache.
NeoBundle 'Shougo/neocomplete.vim'

" Snippets
NeoBundle 'Shougo/neosnippet.vim'
NeoBundle 'Shougo/neosnippet-snippets'

" Git wrapper. Used in status bar.
NeoBundle 'tpope/vim-fugitive'

" Used in status bar.
NeoBundle 'Shougo/unite.vim'

" Tree explorer.
NeoBundle 'scrooloose/nerdtree'

" A collection of language packs for Vim.
NeoBundle 'sheerun/vim-polyglot'

" Pandoc.
"NeoBundle 'vim-pandoc/vim-pandoc'
"NeoBundle 'vim-pandoc/vim-pandoc-syntax'

" You can specify revision/branch/tag.
NeoBundle 'Shougo/vimshell', { 'rev' : '3787e5' }

" Required:
call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

"------------------"
" {Plugins config} "
"------------------"

" Nerdtree
map <C-m> :NERDTreeToggle<CR>

" NeoComplete
let g:neocomplete#enable_at_startup = 1

" Neosnippet

"--------"
" {Maps} "
"--------"

" Save using sudo
cmap w!! w !sudo tee % >/dev/null

" <Leader> key, mapped to \.
let mapleader=","

" Disable Arrow keys in Escape mode
map <up> <nop>
map <down> <nop>
map <left> <nop>
map <right> <nop>

" Toggle 'paste' with ,p.
nnoremap <leader>p :set invpaste paste?<CR>
imap <leader>p <C-O>:set invpaste paste?<CR>
set pastetoggle=<leader>p

" Neosnippet key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" Neosnippet superTab like snippets behavior.
imap <expr><TAB>
 \ pumvisible() ? "\<C-n>" :
 \ neosnippet#expandable_or_jumpable() ?
 \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" Toggle colorcolumn
function! g:ToggleColorColumn()
  if &colorcolumn != 0
    setlocal colorcolumn=0
  else
    setlocal colorcolumn=80
  endif
endfunction
nnoremap <silent> <leader>cc :call g:ToggleColorColumn()<CR>

" Toggle spelling.
map <leader>s :setlocal spell! spelllang=en_gb<CR>

"--------"
" {Misc} "
"--------"

" SWP files path
set backupdir=/tmp
set directory=/tmp

" Mouse support ("all")
set mouse=a

" Show command and mode.
set showcmd

" Don't display the mode in the ruler; we display it in the statusline.
set noshowmode

" Make backspace work like most other apps.
set backspace=2

" Auto indentation.
set autoindent
set copyindent

" Folding
set foldmethod=indent

" Save the undo tree
if ! isdirectory($HOME . "/.vim/undo")
  call mkdir($HOME . "/.vim/undo", "p")
endif
set undofile
" Save it in ~/.vim/undo/.
set undodir=$HOME/.vim/undo

" Use spaces instead of tabs.
set expandtab
set tabstop=2
set shiftwidth=2

" Disable spelling.
set nospell

"--------"
" {Look} "
"--------"

" Enable 256 colours mode (we handle the TTY case further below).
set t_Co=256

" Display and format line numbers.
set number
set numberwidth=4

" Enable UTF-8 (I wanna see Umlauts!).
set encoding=utf8

" Display tabs and trailing whitespaces.
set list
set listchars=tab:→\ ,eol:\ ,trail:·

" Conceal
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif

" Without any syntax highlighting, programming is a pain:
syntax on

" Fix unrecognised file types:
au BufRead,BufNewFile *.md setl filetype=markdown
au BufRead,BufNewFile *.tex setl filetype=tex
au BufRead,BufNewFile *.xbm setl filetype=c
au BufRead,BufNewFile *.frag,*.vert,*.geom,*.glsl setl filetype=glsl"
au BufRead,BufNewFile vimrc,redshift.conf setl filetype=cfg
au BufRead,BufNewFile *.target setl filetype=systemd
au BufRead,BufNewFile *.muttrc setl filetype=muttrc
au BufRead,BufNewFile *.tool setl filetype=scala"
au BufRead,BufNewFile *.zone setl filetype=dns
au BufRead,BufNewFile *.smt setl filetype=lisp

"----------"
" {Colors} "
"----------"

" Statuline mode
hi I_mode ctermfg=8 ctermbg=45
hi N_mode ctermfg=8 ctermbg=148
hi V_mode ctermfg=8 ctermbg=208

" command statusline:
hi cmd_mode              ctermfg=15  ctermbg=64
hi cmd_info              ctermfg=48   ctermbg=0

" default statusline:
hi StatusLine            ctermfg=0   ctermbg=240 cterm=none
hi StatusLineNC          ctermfg=8   ctermbg=240 cterm=none

"---------------"
" {Status Line} "
"---------------"

" Always display the statusline:
set laststatus=2

" Separators
let gitsym=""
let sep="|"
let lnum="LN"

" Active Statusline
function! StatuslineActive()
  let l:statusline = ''
  let l:mode = mode()
  let l:unite = unite#get_status_string()
  let l:git_branch = fugitive#head()

  " Mode
  if l:mode ==? 'v' || l:mode == ''
    let l:statusline .= '%#V_mode#'
    if l:mode ==# 'v'
      let l:statusline .= ' VISUAL '
    elseif l:mode ==# 'V'
      let l:statusline .= ' V·LINE '
    else
      let l:statusline .= ' V·BLOCK '
    endif
  elseif l:mode == 'i'
    let l:statusline .= '%#I_mode# INSERT '
  else
    let l:statusline .= '%#N_mode# NORMAL '
  endif

  " Git
  if l:git_branch != ''
    if l:mode == 'i'
      let l:statusline .= '%#I_git_branch# %{gitsym}'
    else
      let l:statusline .= '%#N_git_branch# %{gitsym}'
    endif
    let l:statusline .= l:git_branch
    if l:mode == 'i'
      let l:statusline .= ' %#I_git_sep#%{sep}'
    else
      let l:statusline .= ' %#N_git_sep#%{sep}'
    endif
  endif
  
  " Filename
  if l:mode == 'i'
    let l:statusline .= '%#I_file#'
  else
    let l:statusline .= '%#N_file#'
  endif
  let l:statusline.=' %<%{expand("%:p:h")}/'
  if l:mode == 'i'
    let l:statusline.='%#I_file_emphasise#'
  else
    let l:statusline.='%#N_file_emphasise#'
  endif
  let l:statusline.='%{expand("%:t")} '

  " Modified
  if &modified
    if l:mode == 'i'
      let l:statusline .= '%#I_file_modified#'
    else
      let l:statusline .= '%#N_file_modified#'
    endif
    let l:statusline .= '* '
  endif

  if l:mode == 'i'
    let l:statusline .= '%#I_middle# '
  else
    let l:statusline .= '%#N_middle# '
  endif

  " Readonly
  if &readonly
    if l:mode == 'i'
      let l:statusline .= '%#I_warning#X%#I_middle# '
    else
      let l:statusline .= '%#N_warning#X%#N_middle# '
    endif
  endif

  " Unite.vim
  if l:unite != ''
    let l:statusline .= ' '.l:unite
  endif

  let l:statusline .= '%='

  " File format, encoding, type, line count
  if l:unite == ''
    let l:ff = &fileformat
    let l:fe = &fileencoding
    let l:ft = &filetype
    if l:ff != 'unix' && l:ff != ''
      if l:mode == 'i'
        let l:statusline .= l:ff.' %#I_middle_sep#%{sep}%#I_middle#'
      else
        let l:statusline .= l:ff.' %#N_middle_sep#%{sep}%#N_middle#'
      endif
    endif
    if l:fe != 'utf-8' && l:fe != 'ascii' && l:fe != ''
      if l:mode == 'i'
        let l:statusline .= l:fe.' %#I_middle_sep#%{sep}%#I_middle#'
      else
        let l:statusline .= l:fe.' %#N_middle_sep#%{sep}%#N_middle#'
      endif
    endif
    if l:ft != ''
      if l:mode == 'i'
        let l:statusline .= l:ft.' %#I_middle_sep#%{sep}%#I_middle#'
      else
        let l:statusline .= l:ft.' %#N_middle_sep#%{sep}%#N_middle#'
      endif
    endif
    let l:statusline .= ' %{lnum} %L '
  endif

  " Buffer position
  if l:mode == 'i'
    let l:statusline .= '%#I_pos#'
  else
    let l:statusline .= '%#N_pos#'
  endif
  let l:statusline .= ' %P '

  " Cursor position
  let l:statusline .= '%#N_cursor_line# %3l'
  let l:statusline .= '%#N_cursor_col#:%02c %#N_middle#'

  return l:statusline
endfunction

" Inactive Statusline
function! StatuslineInactive()
  let l:statusline = ''
  let l:branch = fugitive#head()
  let l:unite = unite#get_status_string()

  " mode:
  let l:statusline .= '        %{sep}'

  " filename:
  let l:statusline.=' %<%t %{sep}'

  " change to the right side:
  let l:statusline.='%='

  " line count:
  let l:statusline .= ' %{lnum} %L '

  " buffer position:
  let l:statusline.='%{sep} %P '

  " cursor position:
  let l:statusline .= '%{sep} %3l:%02c '

  return l:statusline
endfunction "

function! StatuslineCommand()
  return '%#cmd_mode# COMMAND %#cmd_mode_end#%{sep}'
endfunction

" define when which statusline is displayed:
au! BufEnter,WinEnter * setl statusline=%!StatuslineActive()
au! BufLeave,WinLeave * set  statusline=%!StatuslineInactive()
au! CmdwinEnter       * setl statusline=%!StatuslineCommand()

"-------"
" {End} "
"-------"
